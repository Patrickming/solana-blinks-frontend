import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { notFound } from 'next/navigation';
import Link from 'next/link';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { ChevronLeft, ChevronRight, List, ArrowLeft } from 'lucide-react';
import { Button } from '@/app/components/ui/button'; // 确保 Button 组件路径正确
import { ScrollArea } from '@/app/components/ui/scroll-area'; // 引入 ScrollArea

// --- Add imports for TOC generation ---
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeSlug from 'rehype-slug';
import { visit } from 'unist-util-visit';
import { toString } from 'hast-util-to-string'; // Utility to get text from HAST nodes

// --- Type Definition for Headings ---
type Heading = {
  depth: number;
  text: string;
  slug: string; // The ID generated by rehype-slug
};

// --- Helper Functions ---

// Function to get the base path for tutorial content
const tutorialsBasePath = path.join(process.cwd(), 'content', 'tutorials');

// Function to get all lesson slugs for a given course, sorted
function getSortedLessons(courseSlug: string): { slug: string; title: string }[] {
  const coursePath = path.join(tutorialsBasePath, courseSlug);
  try {
    const files = fs.readdirSync(coursePath);
    const lessons = files
      .filter((file) => file.endsWith('.md'))
      .map((file) => {
        const filePath = path.join(coursePath, file);
        const fileContent = fs.readFileSync(filePath, 'utf8');
        const { data } = matter(fileContent); // Parse frontmatter for title
        const slug = file.replace('.md', '');
        return {
          slug: slug,
          title: data.title || slug.replace(/^\d+-/, '').replace(/-/g, ' '), // Use frontmatter title or generate from slug
        };
      });
    // Sort lessons based on filename (assuming numbered prefixes)
    lessons.sort((a, b) => a.slug.localeCompare(b.slug));
    return lessons;
  } catch (error) {
    console.error(`Error reading lessons for course ${courseSlug}:`, error);
    return []; // Return empty array if directory doesn't exist or other error
  }
}

// Modified function to get lesson content AND extract headings with slugs
async function getLessonContent(courseSlug: string, lessonSlug: string): Promise<{
  title: string;
  content: string;
  headings: Heading[];
} | null> {
  const filePath = path.join(tutorialsBasePath, courseSlug, `${lessonSlug}.md`);
  try {
    const fileContent = fs.readFileSync(filePath, 'utf8');
    const { data, content } = matter(fileContent);
    const title = data.title || lessonSlug.replace(/^\d+-/, '').replace(/-/g, ' ');

    // --- Process content to extract headings with slugs ---
    const headings: Heading[] = [];

    // Custom rehype plugin to extract headings AFTER rehype-slug adds IDs
    const extractHeadingsPlugin = () => (tree: any) => {
      visit(tree, 'element', (node: any) => {
        // Target h2 and h3 headings
        if (node.tagName === 'h2' || node.tagName === 'h3') {
          const id = node.properties?.id as string;
          const text = toString(node);
          if (id && text) {
            headings.push({
              depth: parseInt(node.tagName.substring(1), 10),
              text: text,
              slug: id,
            });
          }
        }
      });
    };

    // --- Use .run() instead of .process() ---
    const processor = unified()
      .use(remarkParse)
      .use(remarkGfm)
      .use(remarkRehype)
      .use(rehypeSlug)
      .use(extractHeadingsPlugin);

    // 1. Parse the content into an AST (Abstract Syntax Tree)
    const tree = processor.parse(content);
    // 2. Run the plugins on the tree
    await processor.run(tree);
    // Headings are now populated by the extractHeadingsPlugin via side effect

    return {
      title,
      content, // Return the raw markdown content
      headings, // Return the extracted headings
    };

  } catch (error) {
    console.error(`Error reading or processing lesson ${courseSlug}/${lessonSlug}:`, error);
    return null;
  }
}

// --- Page Component ---

export default async function LessonPage({ params }: { params: { courseSlug: string; lessonSlug: string } }) {
  const { courseSlug, lessonSlug } = params;

  const lessonData = await getLessonContent(courseSlug, lessonSlug);
  const allLessons = getSortedLessons(courseSlug);

  if (!lessonData) {
    notFound(); // Trigger 404 if lesson file not found
  }

  const { title, content, headings } = lessonData;

  // Find current lesson index
  const currentLessonIndex = allLessons.findIndex((l) => l.slug === lessonSlug);

  // Determine previous and next lessons
  const prevLesson = currentLessonIndex > 0 ? allLessons[currentLessonIndex - 1] : null;
  const nextLesson = currentLessonIndex < allLessons.length - 1 ? allLessons[currentLessonIndex + 1] : null;

  return (
    <div className="flex flex-col lg:flex-row gap-8 max-w-7xl mx-auto px-4 py-8">
      {/* Left Sidebar - Combined Table of Contents */}
      <aside className="w-full lg:w-64 lg:sticky lg:top-20 lg:self-start order-2 lg:order-1">
        <div className="bg-card p-4 rounded-lg border shadow-sm space-y-6">
          {/* Course Table of Contents */}
          <div>
            <h3 className="text-lg font-semibold mb-3 flex items-center">
              <List className="mr-2 h-5 w-5" />
              课程目录
            </h3>
            <ScrollArea className="h-auto max-h-60"> {/* Limit height for course list */}
              <nav className="flex flex-col space-y-1 pr-2"> {/* Added padding right */}
                {allLessons.map((l, index) => (
                  <Link
                    key={l.slug}
                    href={`/tutorials/${courseSlug}/${l.slug}`}
                    className={`block px-3 py-2 text-sm rounded-md transition-colors truncate ${
                      l.slug === lessonSlug
                        ? 'bg-primary/10 text-primary font-medium'
                        : 'text-muted-foreground hover:bg-muted hover:text-foreground'
                    }`}
                    title={l.title} // Add title attribute for full text on hover
                  >
                    {l.title}
                  </Link>
                ))}
              </nav>
            </ScrollArea>
          </div>

          {/* On This Page Table of Contents (only if headings exist) */}
          {headings && headings.length > 0 && (
            <div className="pt-6 border-t">
              <h3 className="text-lg font-semibold mb-3">
                本页目录
              </h3>
              <ScrollArea className="h-auto max-h-[calc(100vh-25rem)]"> {/* Adjust max height as needed */}
                <nav className="flex flex-col space-y-1 pr-2"> {/* Added padding right */}
                  {headings.map((heading) => (
                    <Link
                      key={heading.slug}
                      href={`#${heading.slug}`} // Link to the heading ID
                      className={`block py-1 text-sm transition-colors hover:text-primary ${
                          heading.depth === 3 ? 'ml-4' : '' // Indent H3 headings
                      }`}
                    >
                      {heading.text}
                    </Link>
                  ))}
                </nav>
              </ScrollArea>
            </div>
          )}
        </div>
      </aside>

      {/* Main Content Area */}
      <main className="flex-1 min-w-0 order-1 lg:order-2">
        {/* --- Add Back Button --- */}
        <div className="mb-6">
          <Button asChild variant="outline" size="sm">
            <Link href="/tutorials" className="inline-flex items-center">
              <ArrowLeft className="mr-2 h-4 w-4" />
              返回教程列表
            </Link>
          </Button>
        </div>
        {/* --- End Back Button --- */}

        <article className="prose prose-slate dark:prose-invert max-w-none bg-card p-6 md:p-8 rounded-lg border shadow-sm">
          {/* We are using prose for styling the markdown */}
          <h1>{title}</h1>
          <ReactMarkdown remarkPlugins={[remarkGfm]} rehypePlugins={[rehypeSlug]}>
            {content}
          </ReactMarkdown>
        </article>

        {/* Bottom Navigation */}
        <div className="flex justify-between mt-8 pt-6 border-t">
          <div>
            {prevLesson ? (
              <Button asChild variant="outline">
                <Link href={`/tutorials/${courseSlug}/${prevLesson.slug}`}>
                  <ChevronLeft className="mr-2 h-4 w-4" />
                  上一节: {prevLesson.title}
                </Link>
              </Button>
            ) : (
               <Button variant="outline" disabled>
                 <ChevronLeft className="mr-2 h-4 w-4" />
                 已经是第一节
               </Button>
            )}
          </div>
          <div>
            {nextLesson ? (
              <Button asChild variant="outline">
                <Link href={`/tutorials/${courseSlug}/${nextLesson.slug}`}>
                  下一节: {nextLesson.title}
                  <ChevronRight className="ml-2 h-4 w-4" />
                </Link>
              </Button>
            ) : (
              <Button variant="outline" disabled>
                课程已完结
                <ChevronRight className="ml-2 h-4 w-4" />
               </Button>
            )}
          </div>
        </div>
      </main>
    </div>
  );
}

// --- Metadata (Optional but recommended) ---
// You might want to dynamically generate metadata based on the lesson
// export async function generateMetadata({ params }) {
//   const { courseSlug, lessonSlug } = params;
//   const lesson = getLessonContent(courseSlug, lessonSlug);
//   return {
//     title: lesson ? `${lesson.title} - Course ${courseSlug}` : 'Lesson Not Found',
//   };
// }

// --- Static Params Generation (Optional but good for performance) ---
// If your lessons don't change often, generate static paths at build time
// export async function generateStaticParams() {
//   const courseDirs = fs.readdirSync(tutorialsBasePath);
//   const params = [];
//   for (const courseSlug of courseDirs) {
//     const coursePath = path.join(tutorialsBasePath, courseSlug);
//     if (fs.statSync(coursePath).isDirectory()) {
//        const lessons = getSortedLessons(courseSlug);
//        for (const lesson of lessons) {
//          params.push({ courseSlug: courseSlug, lessonSlug: lesson.slug });
//        }
//     }
//   }
//   return params;
// } 